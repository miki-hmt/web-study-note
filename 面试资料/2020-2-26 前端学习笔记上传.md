## 目录

[TOC]



## 常见面试点



#### 1.做下自我介绍和项目介绍

我是淮阴师范学院2017年毕业生，

### ============== JS

#### 1. 闭包

> 含义：闭包是指有权访问另一个函数作用域变量的函数

> **创建闭包的通常方式，是在一个函数内部创建另一个函数**
>
> 1、概念
>
> 简单来说，就是函数A里有一个函数B，函数B可以访问函数A中的参数和变量，那么函数B就是闭包
>
> 闭包函数：声明在一个函数中的函数，叫做闭包函数。
>
> 闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
>
> 2、特点
>   **让外部访问函数内部变量成为可能；**
>
>   局部变量会常驻在内存中；
>
>   可以避免使用全局变量，防止全局变量污染；
>
>   **会造成内存泄漏**（有一块内存空间被长期占用，而不被释放）=

##### 作用域

含义：变量的可用范围

类型：

全局作用域：window

> 全局变量：

```
优点：随处可用，可反复使用

      缺点：极易被全局污染，尽量不使用全局变量
```

1. 函数作用域：活动对象AO

   局部变量：

   > 优点：仅函数内可用，不会被污染
   > 缺点：无法反复使用

##### 作用域链

> 含义：有多级作用域对象组成的链式结构，保存着所有变量，控制变量的使用顺序 书本：当代码在一个执行环境中执行时，会创建变量对象的一个作用域链(scope chain)，作用域链用来指定执行环境有权访问的所有变量和函数的访问顺序；

#### 3. 原型和原型链 new的实现

##### 原型

> 原型分为显式原型prototype和隐式原型，**基本上所有类型都拥有隐式原型**，在一些浏览器里隐式被叫做 **proto**。
> 可以理解为 显式原型为自身的原型，隐式原型__proto__为一个引用，指向的是父级的原型。

##### 原型链

> 原型链的作用主要是实现继承机制，方法就是不断的通过__proto__查找父级的原型。
> `子类.__proto__=父类.prototype， 父类.prototype.__proto__=Object.prototype, Object.prototype.__proto__=null`

####  4.改变this指向的方法 区别,实现 

三种方式：bind，call，apply

1、call,apply和bind的区别
它们在功能上是没有区别的，都是改变this的指向，它们的区别主要是在于方法的**实现形式和参数**传递上的不同。**call和apply方法都是在调用之后立即执行的。而bind调用之后是返回原函数，需要再调用一次才行**，
2、

①：函数.call(**this要指向的对象,arg1,arg2**....)
②：函数.apply(**this要指向的对象，[arg1,arg2,...]**)
③：var ss=函数.bind(**this要指向的对象,arg1,arg2,....)   ss（**）要调用

```javascript
call()-- 立即执行的
apply()---后面参数为数组  立即执行的
bind()--需要调用

var obj = {
    name: "小何",
    age: 18
}
function fn(a, b) {
    console.log(a, b);
    console.log(this);     //bind改变this指向，     
}

fn(10, 20)
fn.prototype.__proto__.__proto__  = null

// 10 20
// 默认this指向Window {parent: Window, opener: null, top: Window, length: 6, frames: Window, …}


//call 函数.call(对象,arg1,arg2....)
var res = fn.call(obj, 5 6)//传参后直接指向，不需要调用，其它都一样
// 5 6
// {name: "小何",age: 18}

//apply 函数.call(对象,arg1,arg2....)
var res=fn.apply(10,[5,6])//传参就调用，不过参数为数组
// 5 6
// Number {10}

//bind
var res = fn.bind(obj, 5, 6) //需要调用，三个参数，第一个位this的指向，后两个为原函数的参数
res()
// 5 6
// Number {10}

```


#### 5. 堆栈存储 浅拷贝和深拷贝

> 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
> 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

##### 浅拷贝的实现方式 （新旧对象还是共享同一块内存）

> 1.Object.assign()
> 可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身 2.Array.prototype.concat() 数组连接 3.Array.prototype.slice(begin,end) 数组截取
>
> > 修改新对象会改到原对象:

```javascript
// 使用slice方法从myCar中创建一个newCar.
var myHonda = { color: 'red', wheels: 4, engine: { cylinders: 4, size: 2.2 } };
var myCar = [myHonda, 2, "cherry condition", "purchased 1997"];
var newCar = myCar.slice(0, 2);

// 输出myCar, newCar,以及各自的myHonda对象引用的color属性.
console.log('myCar = ' + JSON.stringify(myCar));
console.log('newCar = ' + JSON.stringify(newCar));
console.log('myCar[0].color = ' + JSON.stringify(myCar[0].color));
console.log('newCar[0].color = ' + JSON.stringify(newCar[0].color));

// 改变myHonda对象的color属性.
myHonda.color = 'purple';
console.log('The new color of my Honda is ' + myHonda.color);

//输出myCar, newCar中各自的myHonda对象引用的color属性.
console.log('myCar[0].color = ' + myCar[0].color);
console.log('newCar[0].color = ' + newCar[0].color);

```

##### 深拷贝的实现方式（新对象跟原对象不共享内存）

1. JSON.parse(JSON.stringify(arr)),

> 这种方法虽然可以实现数组或对象深拷贝,但不能处理函数

1. 手写递归方法(递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝)

```javascript
    //定义检测数据类型的功能函数
    function checkedType(target) {
      return Object.prototype.toString.call(target).slice(8, -1)
    }
    //实现深度克隆---对象/数组
    function clone(target) {
      //判断拷贝的数据类型
      //初始化变量result 成为最终克隆的数据
      let result, targetType = checkedType(target)
      if (targetType === 'Object') {
        result = {}
      } else if (targetType === 'Array') {
        result = []
      } else {
        return target
      }
      //遍历目标数据
      for (let i in target) {
        //获取遍历数据结构的每一项值。
        let value = target[i]
        //判断目标结构里的每一值是否存在对象/数组
        if (checkedType(value) === 'Object' ||
          checkedType(value) === 'Array') { //对象/数组里嵌套了对象/数组
          //继续遍历获取到value值
          result[i] = clone(value)
        } else { //获取到value值是基本的数据类型或者是函数。
          result[i] = value;
        }
      }
      return result
    }

```

1. **函数库lodash**<https://www.lodashjs.com/docs/>

> **lodash是一个js工具库**，内部封装了很多字符串、数组、对象等常见**数据类型的处理函数**。 es6 引入:**import _ from 'lodash**'

- chunk，将数组进行切分。
- 去除假值,（将所有的空值，0，NaN过滤掉）
- 数组去重
- filter和reject，过滤集合，传入匿名函数。（二者放在一起讨论的原因是，两个函数类似但返回的值是相反。）
- **map和forEach**，数组遍历。
- merge,参数合并。
- extend，类似参数对象合并。
- cancat，数组连接
- keys ，取出对象中所有的key值组成新的数组

```
var objects = [{ 'a': 1 }, { 'b': 2 }];
 //浅拷贝
var shallow = _.clone(objects);
console.log(shallow[0] === objects[0]);
// => true

 //深拷贝
var deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// => false
```

#### 6. 前端缓存localstorage sessionstorage cookie区别

##### 文档源

协议:http,https; 主机名:www.example.com 端口号:8080

##### 顶级窗口

> 一个浏览器标签页包含两个<iframe> 元素，它们所包含的文档是同源的，那么这两者就可以共享sessionStorage

##### localStorage

1. 存储有效期：存储的数据是永久的
2. 作用域:限定在文档源级别 -->同源的文档源可以共享同样localStorage的数据
3. 不同浏览器供应商不能共享

```javascript
localStorage.setItem("name","hmt")
localStorage.getItem("name")

```

##### sessionStorage

1. 存储有效期：一旦窗口或标签页被永久关闭了，数据就都没了，除非浏览器的恢复上一次会话功能
2. 作用域:限定在文档源级别,限定在顶级窗口（标签页）中

```javascript
sessionStorage.setItem("name","hmt")
sessionStorage.getItem("name")

```

##### cookies

1. 存储有效期：他只能持续在web浏览器的会话期间，一旦用户关闭浏览器，数据就没了。max-age可以延长有效期单位是秒，设置后存到本地
2. 作用域:通过文档源和文档路径决定，来自同一个web服务器的web页面，只要其url是指定的路径前缀开始的，都可以共享cookies

##### localStorage 和 sessionStorage 的应用场景：

1. localStorage 常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。
2. sessionStorage适用于敏感账号一次性登录

#### 7. 事件捕获冒泡 事件委托
##### 事件冒泡
>从实际操作的元素（事件）上级父元素一级一级执行下去，直到到达<html>
>  有些时候父元素和子元素都定义了click事件，但是不希望点击子元素的时候执行父元素的click事件（例如dialog弹窗的遮罩层如果是父元素，而dialog弹窗内容层是子元素，同时可以通过点击遮罩层来关闭弹窗，但是点击内容层不关闭弹窗），**可以通过stopPropagation()在子元素上阻止冒泡**。

##### 事件冒泡

> 从实际操作的元素（事件）向上级父元素一级一级执行下去，直到达到<html>

```
有些时候父元素和子元素都定义了click事件，但是不希望点击子元素的时候执行父元素的click事件（例如dialog弹窗的遮罩层如果是父元素，而dialog弹窗内容层是子元素，同时可以通过点击遮罩层来关闭弹窗，但是点击内容层不关闭弹窗），可以通过stopPropagation()在子元素上阻止冒泡。
```

##### 事件捕获（一般不会用到）

> 浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。
> 然后，它移动到<html>中的下一个元素(点击的元素的父元素)，并执行相同的操作，然后是下一个元素(点击的元素的父元素)，依此类推，直到到达实际点击的元素。

##### 事件委托使用场景

> 如果你想要在大量子元素（包括动态添加的）中单击任何一个就可以运行一段代码，这个时候可以把事件监听器设置在父节点上。
> 实现方式 jquery 中的 on

##### 三者的关系是怎样的呢

> 一、事件捕获和冒泡是现代浏览器的执行事件的两个不同阶段
> 二、事件委托是利用冒泡阶段的运行机制来实现的

#### 8. 浏览器http缓存 强缓存和协商缓存(304)

#### 9.  跨域的解决方案

其实我们通常所说的跨域是狭义的，**是由浏览器同源策略限制的一类请求场景**。（跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。）

所谓**同源是指"协议+域名+端口"三者相同**，即便两个不同的域名指向同一个ip地址，也非同源

##### 常见跨域场景

```
URL                                      说明                    是否允许通信
http://www.domain.com/a.js
http://www.domain.com/b.js         同一域名，不同文件或路径           允许
http://www.domain.com/lab/c.js

http://www.domain.com:8000/a.js
http://www.domain.com/b.js         同一域名，不同端口                不允许
 
http://www.domain.com/a.js
https://www.domain.com/b.js        同一域名，不同协议                不允许
 
http://www.domain.com/a.js
http://192.168.4.12/b.js           域名和域名对应相同ip              不允许
 
http://www.domain.com/a.js
http://x.domain.com/b.js           主域相同，子域不同                不允许
http://domain.com/c.js
 
http://www.domain1.com/a.js
http://www.domain2.com/b.js        不同域名                         不允许
```

##### **跨域解决方案**

1、 通过**jsonp**跨域
2、 **document.domain + iframe**
3、 **location**.**hash** + iframe
4、 **window.name** + iframe
5、 **postMessage**跨域
6、 **跨域资源共享**（**CORS**）
7、 **nginx**代理跨域
8、 **nodejs中间件代理**跨域
9、 **WebSocket协议**跨域

#### 10.执行栈

##### (1)执行上下文 (全局、函数、eval)

> **JavaScript中执行环境:全局环境---函数环境---eval函数环境 （已不推荐使用）**

> **执行上下文的类型:全局执行上下文--函数执行上下文--eval执行上下文**
##### (2) 执行栈(函数调用栈)
>在JavaScript中，通过栈的存取方式来**管理执行上下文**，我们可称其为执行栈，或函数调用栈(Call Stack)。
##### (3) 栈数据结构特点

>栈遵循**"先进后出，后进先出"**的规则，或称**LIFO**
>出口在顶部，且仅有一个

#####(4) 执行上下文的生命周期:创建阶段、执行阶段

   创建阶段的操作

1. 创建变量对象：函数环境会初始化创建`Arguments`对象（赋值）---->函数声明（赋值）---->变量声明**未赋值**），函数表达式声明（**未赋值**）
2. 确定this指向（**this由调用者确定**）
3. 确定作用域（**词法环境决定，哪里声明定义，就在哪里确定**）

执行阶段的操作

1. 变量对象赋值：变量赋值  、函数表达式赋值
2. 调用函数
3. 顺序执行其它代码

##### (5) 小结

1. **JavaScript是单线程**
2. 栈顶的执行上下文处于执行中，其它需要排队
3. 全局上下文只有一个处于栈底，页面关闭时出栈
4. **函数执行上下文可存在多个，但应避免递归时堆栈溢出**
5. 函数调用时就会创建新的上下文，即使调用自身，也会创建不同的执行上下文

#### 11.js中数据类型

其中`Undefined`、`Null`、`Boolean`、`Number`和`String`属于基本类型|值类型（5种）。`Object`、`Array`和`Function`则属于引用类型，`String`有些特殊，具体的会在下面展开分析。

##### **值类型和引用类型的区别**

（1）**值类型**：1、占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，`基础变量的值是存储在栈中`，而引用变量存储在栈中的是`指向堆中的数组或者对象的地址`，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）

​                        2、**保存与复制的是值本身**

​                        3、使用**typeof**检测数据的类型

​                        4、**基本类型数据是值类型**

（2）**引用类型**：1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象`依然不会被销毁`，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）

​                           2、**保存与复制的是指向对象的一个指针**

​                           3、使用**instanceof**检测数据类型

​                           4、使用new()方法构造出的对象是引用型



#### 12.http与https原理区别

>1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
>2. http是**超文本传输协议**，信息是**明文**传输，https则是具有安全性的**ssl加密**传输协议。
>3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是**443**。
>4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,比http协议安全


**http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议**

#####   HTTP + 加密 + 认证 + 完整性保护 = HTTPS

http是明文传输，所谓https，其实就是身披ssl协议这层外壳的http

https比http多了一层SSL or TLS层(安全套接层)，	从而保护了交换数据隐私和完整性，提供对网站服务器的身份认证功能。

###### 对称秘钥加密和非对称秘钥加密

#### 13.cdn原理和Dns查询方式

1. 什么是CDN？

>CDN的全称是Content Delivery Network，即**内容分发网络**。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。**CDN的关键技术主要有内容存储和分发技术**。

2. 基本原理
 > CDN的基本原理是广泛**采用****各种缓存服务器**，将这些缓存服务器**分布**到用户访问相对集中的**地区或网络**中，在用户访问网站时，利用**全局负载技术**将用户的访问指向**距离最近的工作正常的缓存服务器**上，由**缓存服务器**直接**响应用户请求**。
3. Dns查询方式
 > 非递归（不建议使用）
 > 递归查询
 > 迭代查询

#### 14.JS设计模式-观察者模式（核心）

#### 15.typeof vs instanceof

`typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型

```
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'

```

`typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型

```
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'

```

如果我们想判断一个对象的正确类型，这时候可以考虑使用 `instanceof`，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 `instanceof`。

```
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true

```

对于原始类型来说，你想直接通过 `instanceof` 来判断类型是不行的，当然我们还是有办法让 `instanceof` 判断原始类型的

```
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true

```

你可能不知道 `Symbol.hasInstance` 是什么东西，其实就是一个能让我们自定义 `instanceof` 行为的东西，以上代码等同于 `typeof 'hello world' === 'string'`，所以结果自然是 `true` 了。这其实也侧面反映了一个问题， `instanceof` 也不是百分之百可信的。

#### http常用状态码

###### 1XX：通知：100("Continue"  )重要程度：中等，但（写操作时）很少用。

###### 2XX: 成功

200：**请求被正常处理**
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。

###### 3XX 重定向

**301：永久性重定向**
302：临时重定向
303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法

###### 4XX：客户端错误

**400：请求报文语法有误，服务器无法识别**
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源

###### 5XX 服务端错误

**500：服务器内部错误**
**503：服务器正忙**

```jsx
import { fetch } from 'dva';
import { notification } from 'antd';
import router from 'umi/router';

const codeMessage = {
  200: '服务器成功返回请求的数据。',
  201: '新建或修改数据成功。',
  202: '一个请求已经进入后台排队（异步任务）。',
  204: '删除数据成功。',
  400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',
  401: '用户没有权限（令牌、用户名、密码错误）。',
  403: '用户得到授权，但是访问是被禁止的。',
  404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  422: '当创建一个对象时，发生一个验证错误。',
  500: '服务器发生错误，请检查服务器。',
  502: '网关错误。',
  503: '服务不可用，服务器暂时过载或维护。',
  504: '网关超时。',
};

/**
 *
 * @param {用户名} params.username
 * @param {密码} params.pwd
 */

export default async function request(url, options) {
  // 发起请求 https://cjy-react-interface.herokuapp.com/api/users/login
  return await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
    },
  })
    .then(checkStatus)
    .catch(checkErrorStatus);
}

function checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response.json();
  }

```



### ========es6

#### 1.小结

```javascript
定义变量/常量: const/let
解构赋值: let {a, b} = this.props   import {aa} from 'xxx'
对象的简洁表达: {a, b}
箭头函数: 
	组件的自定义方法: xxx = () => {}
	map/filter的回调方法: (item, index) => {}
	优点:
		* 简洁
		* 没有自己的this,使用引用this查找的是外部this
扩展运算符: ...
	拆解对象:  const MyProps = {}, <Xxx {...MyProps}>
类: class/extends/constructor/super
ES6模块化: export default | import

- 变量定义——let和const
- 函数的变化——箭头函数、剩余参数
- 数组的变动——解构，展开符
- 字符串——模版字符串、startsWith、endsWith
- Iterator和for...of
- Generator和Promise
- Class和extends
```

#### 2. var let const 区别

##### var特性：

- 有变量提升，提升到当前作用域的最前

##### let特性：

- 不会有变量提升

- 声明所在作用域存在暂时性死区

- 不能重复声明（无论是var let 或let let 或let var 都不行）

  > 暂时性死区：在块级作用域中，从块级的顶部到变量申明之前，这一区域是不允许使用该变量的，否则报错，即使是typeof 全局变量不再属于window对象：在全局let声明的变量不再属于顶层对象(window) 即 let a=1;console.log(window.a)//undefined

##### const特性:

- 声明时必须赋值
- 常量本身不能改变
- 存在暂时性死区，不能声明

> 注意：如果const常量对应的是一个对象，则不能对常量重新赋值，但是可以改变这个对象的属性~~

#### 3.箭头函数()=>{} 与function的区别

  >    箭头函数/function函数this的指向

  >   箭头函数和function函数的区别 new/arguments/prototype/Generator

- 定义方法不同

-  this指向不同

   > 使用**function**定义的函数，this的指向随着调用环境的变化而**变化的**，而**箭头函数**中的this指向是**固定不变的**，

-  function是可以定义构造函数的，而箭头函数是不行的

-  变量提升：箭头函数一定要定义于调用之前

```
//定义方法
  //function
  function fn(a, b){
  	return a + b;
  }
  //arrow function
  var foo = (a, b)=>{ return a + b };

//function函数能够变量提升
foo(); //123
function foo(){
	console.log('123');
}
//箭头函数一定要定义于调用之前
arrowFn(); //Uncaught TypeError: arrowFn is not a function
var arrowFn = () => {
	console.log('456');
};
```

#### 4. es6数组方法 forEach和map区别
> forEach() 方法对数组的每个元素执行一次提供的函数。 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

```
var kvArray = [{key: 1, value: 10}, 
               {key: 2, value: 20}, 
               {key: 3, value: 30}];

var reformattedArray = kvArray.map(function(obj) { 
   var rObj = {};
   rObj[obj.key] = obj.value;
   return rObj;
});

// reformattedArray 数组为： [{1: 10}, {2: 20}, {3: 30}], 

// kvArray 数组未被修改: 
// [{key: 1, value: 10}, 
//  {key: 2, value: 20}, 
//  {key: 3, value: 30}]

```

#### 5. promise的内部实现

##### 1.概念

>promise用来**实现异步操作**，解决了**回调地狱**的问题

所谓的promise简单来说就是一个容器，里面保存着某些**未来才结束**的事件（通常是一个异步操作）的结果。
从语法上来讲，**Promise是一个对象**，从它可以获取一步操作的消息。Promise对象的状态不受外部影响。

promise接受一个函数作为参数，函数里有resolve和reject两个参数，这两个参数其实都是**promise的内置方法**，会在异步操作结束后调用，可以将异步操作的结果返回至回调函数promise上面的方法
```jsx
const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
Promise.all()
Promise.race()
Promise.resolve()  异步操作成功后调用   pending--->fulfilled
Promise.reject()   异步操作失败后调用   pending--->rejected
```


**Promise 新建后就会立即执行。**

##### 2.Promise.prototype.then

then方法的作用是给 Promise 实例**添加状态改变时的回调函数**。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数
```jsx
//promise实例确定后，可以通过then方法传进去两个函数分别对应fulfilled状态和rejected状态的回调函数
Promise.prototype.then((success)=>{
},(error)=>{
}) 
```

##### 3.Promise.prototype.catch

Promise.prototype.catch()方法是.then(null,rejection)的别名。用于指定**发生错误时**的回调函数

```jsx
p.then((val) => console.log('fulfilled:', val)).catch((err) => console.log('rejected', err));

// 等同于
p.then((val) => console.log('fulfilled:', val)).then(null, (err) => console.log("rejected:", err));
```
##### 4.Promise.resolve()   将现有对象转为 Promise 对象

```
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

```javascript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise   Promise 新建后就会立即执行。
// Hi!
// resolved     then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。

setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。
```

##### 2.应用场景

连续的调用返回promise实例的情况

```
const p = new Promise(function(resolve, reject){
  if(/*异步操作的成功*/){
    resolve(value)
  } else {
    reject(error)
  }
});
p.then(function(){
}).then(function(){
}).then(function(){
}).catch(function(e){
  // failure
})
```

##### 3.promise实现原理，源码

```
const PENDING = 'pending'; //初始状态
const FULFILLED = 'fulfilled'; // 成功状态
const REJECTED = 'rejected'; // 成功
function Promise(extutor){
  let self = this;
  self.status = PENDING; // 设置状态
  // 存放成功回调的数组
  self.onResolveCallbacks = [];
  // 存放失败回调的数组
  self.onRejectedCallbacks = [];
  function resolve(value){
    if(self.status === PENDING){
      self.status = FULFILLED;
      self.value = value;
      self.onResolveCallbacks.forEach(cb => cd(self.value))
    }
  } 
  function reject(reason){
    if(self.status === PENDING){
      self.status = REJECTED;
      self.value = reason;
      self.onRejectCallbacks.forEach(cb => cd(self.value))
    }
  } 
  try{
    excutor(resolve, reject)
  } catch(e) {
    reject(e)
  }
}
```

`then`方法在调用then方法中传进去的时候是两个函数，分别对应的是`promise`中的一步方法成功和失败的回调

```
Promise.prototype.then = function(onFulfilled, onRejected){
  // 如果成功和失败的回调没有传，表示这个then没有任何逻辑，只负责把值往后抛
  onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : value => value
  onRejected = typeof onRejected == 'function' ? onRejected : reason => { throw reason }
  let self = this;
  let promise2;
  // 实现链式调用，每一种状态都要返回的是一个promise实例
  if(self.status == FULFILLED){ // 如果promise状态已经是成功态，onFulfilled直接取值
    return  promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){  // 保证返回的promise是异步
        try{
          onFulfilled(self.value)
        } catch (e){
          //  如果执行成功的回调过程中出错，用错误原因把promise2 reject
          reject(e)
        }
      })
    })
  }
  if( self.status == REJECTED){
    return promise2 = new Promise(function(){
      setTimeout(function(){
        try{
          onFulfilled(self.value)
        } catch (e){
          reject(e)
        }
      })
    })
  }
  if(self.status === PENDING){
    return promise2 = new Promise(function(resolve, reject){
      // pending 状态时就会把所有的回调函数都添加到实例中的两个堆栈中暂存，等状态改变后依次执行，其实这个过程就是观察者模式
      self.onResolveCallbacks.push(function(){
        setTimeOut(function(){
          try{
            onFulfilled(self.value)
          } catch(e){
            reject(e)
          }
        })
      })
    })
    self.onRejectCallbacks.push(){
      setTimeOut(function(){
        try{
          onRejected(self.value)
        } catch(e){
          reject(e)
        }
      })
    }
  }
}
```



#### 6. async await 内部实现的 与generator区别

Promise 允许将回调函数的嵌套，改成链式调用，最大问题是代码冗余,一堆then

**Generator** 函数是协程在 ES6 的实现，最大特点就是可以**交出函数的执行权**（即暂停执行）。

整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用`yield`语句注明

```
var fetch = require('node-fetch');

function* gen(){
  var url = 'https://api.github.com/users/github';
  var result = yield fetch(url);
  console.log(result.bio);
}
var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
```

**async** **函数=** **Generator 函数的语法糖**

`async`函数就是将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`，仅此而已。



`async`函数对 Generator 函数的改进，体现在以下四点。

（1）内置执行器。（2）更好的语义：`async`表示函数里有异步操作，`await`表示**紧跟在后面的表达式需要等待结果**。

（3）更广的适用性。

（4）返回值是 Promise：

`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。

```
async function f() {
  // 等同于
  // return 123;
  return await 123;
}
f()  //结果 Promise {<resolved>: 123}
```



#### 7. Babel-polyfill  babel原理 （ATS）

#### 9.解构赋值

这里有一个难点，就是：

```javascript
import React, {Component} from 'react'
```

这其实是ES6的语法-解构赋值，如果你分开写就比较清楚了，你可以把上面一行代码写成下面两行.

```
import React from 'react'
const Component = React.Component
```

#### 10.数组解构

​    用于变量声明

```
let color = ['red', 'green', 'blue'];
let [firstColor, secondColor] = color;
console.log(firstColor); //red
console.log(secondColor); //green
```

#### 11.对象解构

```
//原始获取对象属性时的写法，需要S不停的声明变量来获取
const Asher = {
    name: 'Asher Zhang',
    age: 5,
    family: {
        mother: 'North Zhang',
        father: 'Richard Zhang',
        brother: 'Howard Zhang'
    }
}
const name = Asher.name;           //Asher Zhang
const age = Asher.age;                //5
//对象结构的写法，意思是先声明变量name和age，然后在对象Asher中寻找同名属性，最后将属性值赋值给变量name和
const {name,age,family} = Asher; 
//如果在此之前已经声明过变量name了，会报错
//加上()之后就可以了，因为不加()时，浏览器会将{}解析为代码块，而不是解构
({name,age} = Asher);    
```

#### 12.Generator生成器函数

`function*` 这种声明方式(`function`关键字后跟一个星号）会定义一个**生成器函数** (generator function)，它返回一个  [`Generator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)  对象。

```js
// 定义生成器函数
function* g() { 
	yield 'a';
	yield 'b';
	yield 'c';
	return 'ending';
}
// 返回Generator对象
console.log(g()); // g {<suspended>}
console.log(g().toString()); // [object Generator]
```

##### **生成器函数**在执行时能暂停，后面又能从暂停处继续执行：

```js
function* g() {
      yield 'a';
      yield 'b';
      yield 'c';
      return 'ending';
}

var gen = g()
console.log(gen.next()) // {value: "a", done: false}
console.log(gen.next()) // {value: "b", done: false}
console.log(gen.next()) // {value: "c", done: false}
console.log(gen.next()) // {value: "ending", done: true}
```

##### 利用递归执行生成器中所有步骤

```js
function next(){
    let { value, done } = gen.next()
    console.log(value) // 依次打印输出 a b c end
    if(!done) next() // 直到全部完成
}
next()
```

##### 通过next()传值

```js
function* say() {
    let a = yield '1'
    console.log(a)
    let b = yield '2'
    console.log(b)
}

let it = say() // 返回迭代器

// 输出 { value: '1', done: false }
// a的值并非该返回值，而是下次next参数
console.log(it.next()) 
// 输出'我是被传进来的1'
// 输出{ value: '2', done: false }
console.log(it.next('我是被传进来的1'))

// 输出'我是被传进来的2'
// 输出{ value: undefined, done: true }
console.log(it.next('我是被传进来的2'))
```

##### 结合Promise使用

```js
// 使用Generator顺序执行两次异步操作
function* r(num) {
  const r1 = yield compute(num);
  yield compute(r1);
}

// compute为异步操作，结合Promise使用可以轻松实现异步操作队列
function compute(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      const ret = num * num;
      console.log(ret); // 输出处理结果
      resolve(ret); // 操作成功
    }, 1000);
  });
}

// 不使用递归函数调用
let it = r(2);
it.next().value.then(num => it.next(num));

// 修改为可处理Promise的next
function next(data) {
  let { value, done } = it.next(data); // 启动
  if (!done) {
    value.then(num => {
      next(num);
    });
  }
}

next();
```

#### 13.Promise

`Promise`是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更强大。

Promise接收一个用来异步执行的function,这个function接收两个形参,这两个形参在Promise后续的.then传入响应的func。

### ============== CSS
#### 17. css选择器权重

##### 1.类别选择、2.标签选择器、3.ID选择器 、

##### 4.后代选择器（空格分开（可逐级选择，也可跳级选择）、

##### 5.子选择器（通过“>”进行选择：子元素的第一个后代）、

##### 6.伪类选择器：hover、visited（已被点击的链接）、link（未被点击的链接）、active（鼠标已经在其上按下 但是还没有释放）

##### 7.通用选择器（*来表示。选择HTML中所有的部分）

##### 8.群组选择器

| 类型             | 权重   |
| -------------- | ---- |
| ! important    | 无穷   |
| 行间样式           | 1000 |
| id             | 100  |
| class/属性选择器/伪类 | 10   |
| 标签选择器          | 1    |
| 通配符            | 0    |

#### 18. 如何实现水平垂直居中

```
  html, body {
            width: 100%;
            height: 100%;
            margin: 0; 
            padding: 0;
        }
        .content {
            width: 300px;
            height: 300px;
            background: orange;
            margin: 0 auto; /*水平居中*/
        }
        .content {
            width: 300px;
            height: 300px;
            background: orange;
            margin: 0 auto; /*水平居中*/
            position: relative;/*脱离文档流*/
            top: 50%; /*偏移*/
            transform: translateY(-50%);
        }
```

#### 19. link和@import的区别

而在我们学习之初的外部样式表都是用`link`引入的，但是当后来我们学习的逐渐深入，发现`@import`也可以引入样式。那么同样是引入外部样式，这两者有什么区别呢，下面请跟随我来详细了解一下`link`和`@import`的区别吧！

```
<!DOCTYPE html>
 <html lang="en"> 
<head> 
<link rel="stylesheet" rev="stylesheet" href="myCss.css" type="text/css" > 
<style type="text/css" >                
@import url("./myCss.css");            
</style>
 </head> 
</html>
```

这就是两种引用方式的常见用法，可以很清晰的看出

- 1、从属关系：link是html的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；而@import是css的语法，只有导入样式表的作用。
- 2、加载顺序：页面被加载时，link会和html同时被加载而；@import引入的 CSS 将在页面加载完毕后被加载。
- 3、兼容性：@import是 CSS2.1 才有的语法，所以只能在 IE5以上 才能识别；而link是 HTML 标签，所以不存在兼容性问题。
- 4、DOM：javascript只能控制dom去改变link标签引入的样式，而@import的样式不是dom可以控制的。
- 5、link方式的样式权重高于@import的权重。（如果对权重不是十分了解，可以看我之前的文章）

##### **@import最优写法**

```
@import 'style.css' //Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别 @import "style.css" //Windows IE4/ NS4, Macintosh IE4/NS4不识别

@import url(style.css) //Windows NS4, Macintosh NS4不识别

@import url('style.css') //Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别 @import url("style.css") //Windows NS4, Macintosh NS4不识别
```

由上分析知道，@import url(style.css) 和@import url("style.css")是最优的选择，兼容的浏览器最多。从字节优化的角度来看@import url(style.css)最值得推荐。

##### **结论**

`@import`是依赖css的，存在一定的兼容问题，并且根据浏览器渲染机制来说，他在dom树渲染完成后才会渲染，并且不能被js动态修改。

相比之下`link`兼容性较好，且dom元素的样式可以被js动态修改，又因为`link`的权重高于`@import`，所以 **@import适用于引入公共基础样式或第三方样式，link适用于自己写的且需要动态修改的样式**。

#### 20. 如何实现屏幕一半宽度的正方形 
```css
第一种
<div style="width:50%;padding-bottom:50%;height:0px;background:#ccc;">            
</div>

第二种
<div style="width: 50vw; height: 50vw; background:green;">          
</div>
```
#### 21. Transform + zdindex 实现不同层级的卡片重叠
#### 22. BFC的概念

1、概念，全称是block format context，**块级格式化上下文**

2、触发条件

根元素 float属性不为none 

position为absolute或fixed 

display为inline-block, table-cell, table-caption, flex, inline-flex

overflow不为visible

3、应用场景

自适应两栏布局、清除浮动、防止垂直 margin 重叠


### ============== vue
#### 1. 生命周期（钩子函数）

>**beforeCreate**:实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性(**一般不用**)
>**created**:实例已经在内存中创建OK，此时 data 和 methods 已经创建OK（**这时可以调用异步请求，和初始化一些数据**）
>**beforeMound**:此时已经完成了模板的编译，但是还没有挂载到页面中(**一般不用**)
>**mounted**:此时，已经将编译好的模板，挂载到了页面指定的容器中显示（**写操作页面的方法**）
>**beforeUpdate**:状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点（**一般不用**）
>**update**:实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！（**一般不用**）
>**befoeDestory**:实例销毁之前调用。在这一步，实例仍然完全可用。（**一般不用**）
>**destoryed**:实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 （**一般用于清除定时，释放内存**）
>
>1. 总体来说：初始化、运行中、销毁
>
>2. 详细来说：开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程
>
>3. **beforeCreate**（创建前） 在数据观测和初始化事件还未开始
>   **created**（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
>   **beforeMount**（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
>   **mounted**（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。
>   **beforeUpdate**（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
>   **updated**（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
>   **beforeDestroy**（销毁前） 在实例销毁之前调用。实例仍然完全可用。
>   **destroyed**（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。
>   1.什么是vue生命周期？
>   答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。
>
>   2.vue生命周期的作用是什么？
>   答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。
>
>   3.vue生命周期总共有几个阶段？
>   答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。
>
>   4.第一次页面加载会触发哪几个钩子？
>   答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。
>
>   5.DOM 渲染在 哪个周期中就已经完成？
>   答：DOM 渲染在 mounted 中就已经完成了。

#### 2. watch computed method的区别，如何使用

>**data**:存放数据的
>**computed**:计算属性，跟据data中的某些数据得到一个新的数据
>**filters**:过滤器,类似于computed
>**methods**:写方法的，最简单的根据一个数据拼接成另一个数据就直接写在computed中就好了
>**watch**:监听数据变化的(**很重要，我个人用的还是比较多的**)。例如某个数据变化了，我需要重新计算元素的高度，或者去改变别的数据
#### 3. keep-alive原理

##### 介绍

keep-alive是Vue.js的一个内置组件。**它能够不活动的组件实例保存在内存中**，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。它提供了include与exclude两个属性，允许组件有条件地进行缓存。

##### 原理

其实就是在**created**时将需要**缓存的VNode**节点保存在**this.cache**中，在**render**时,如果**VNode的name符合在缓存条件**（可以用include以及exclude控制），则会从this.cache中**取出**之前缓存的**VNode实例**进行渲染。

**keep-alive**是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。

使用方法

```
<keep-alive include='include_components' exclude='exclude_components'>
  <component>
    <!-- 该组件是否缓存取决于include和exclude属性 -->
  </component>
</keep-alive>


```

参数解释
include - 字符串或正则表达式，只有名称匹配的组件会被缓存
exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。

使用示例

```
<!-- 逗号分隔字符串，只有组件a与b被缓存。 -->
<keep-alive include="a,b">
  <component></component>
</keep-alive>

<!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) -->
<keep-alive :include="/a|b/">
  <component></component>
</keep-alive>

<!-- Array (需要使用 v-bind，被包含的都会被缓存) -->
<keep-alive :include="['a', 'b']">
  <component></component>
</keep-alive>


```



#### 4. 自定义指令使用经验(vue-cli如何新增自定义指令？)

1.创建局部指令

```
var app = new Vue({
    el: '#app',
    data: {    
    },
    // 创建指令(可以多个)
    directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        }
    }
})

```

2.全局指令

```
Vue.directive('dir2', {
    inserted(el) {
        console.log(el);
    }
})

```

3.指令的使用

```
<div id="app">
    <div v-dir1></div>
    <div v-dir2></div>
</div>


```



#### 5. 组件通信（组件间的参数传递 :父子，子父，同级）；mixin解决什么样的场景；mixin如何合并的 Vue

**1.父组件与子组件传值**
父组件传给子组件：子组件通过**props**方法接受数据;
子组件传给父组件：**$emit**方法传递参数
**2.非父子组件间的数据传递，兄弟组件传值**
**eventBus**，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。

（虽然也有不少人推荐直接用**VUEX**，具体来说看需求咯。技术只是手段，目的达到才是王道。）

#### 6. 双向绑定原理 Object.defineProperty局限性，和Proxy的差别

vue实现数据双向绑定主要是：采**用数据劫持结合发布者-订阅者模式**的方式，通过**Object.defineProperty（）**来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。

**js实现简单的双向绑定**

```
<body>
    <div id="app">
    <input type="text" id="txt">
    <p id="show"></p>
</div>
</body>
<script type="text/javascript">
    var obj = {}
    Object.defineProperty(obj, 'txt', {
        get: function () {
            return obj
        },
        set: function (newValue) {
            document.getElementById('txt').value = newValue
            document.getElementById('show').innerHTML = newValue
        }
    })
    document.addEventListener('keyup', function (e) {
        obj.txt = e.target.value
    })
</script>


```

#### 7. Vue.use原理
#### 8. Vue-router原理
#### 9. Vuex原理

#### 10.对于MVVM的理解？

MVVM 是 Model-View-ViewModel 的缩写。
**Model**代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
**View** 代表UI 组件，它负责将数据模型转化成UI 展现出来。
**ViewModel** 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
**ViewModel** 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

#### 11.Vue的路由实现：hash模式 和 history模式

**hash模式：**在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。
hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 [http://www.xxx.com](http://www.xxx.com/)，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

**history模式：**history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。
history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。**Vue-Router 官网里如此描述：**“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”

#### 12.Vue与Angular以及React的区别？

（版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟）
**1.与AngularJS的区别**
相同点：
都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

不同点：
AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

**2.与React的区别**
相同点：
React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。
不同点：
React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。

#### 13.vue路由的钩子函数

首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。

**beforeEach**主要有3个参数to，from，next：

**to**：route即将进入的目标路由对象，

**from**：route当前导航正要离开的路由

**next**：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。

#### 14.vuex是什么？怎么使用？哪种功能场景使用它？

只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
在main.js引入store，注入。新建了一个目录store，….. export 。
场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车
![图片描述](https://segmentfault.com/img/bVOAAF?w=701&h=551)

**state**
Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。
**mutations**
mutations定义的方法动态修改Vuex 的 store 中的状态或数据。
**getters**
类似vue的计算属性，主要用来过滤一些数据。
**action** 
actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。

```vue
const store = new Vuex.Store({ //store实例
      state: {
         count: 0
             },
      mutations: {                
         increment (state) {
          state.count++
         }
          },
      actions: { 
         increment (context) {
          context.commit('increment')
   }
 }
})
```

**modules**
项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。

```
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
 }
const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
 }

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
})


```

#### 15、vue如何自定义一个过滤器？

html代码：

```
<div id="app">
     <input type="text" v-model="msg" />
     {{msg| capitalize }}
</div>


```

JS代码：

```
var vm=new Vue({
    el:"#app",
    data:{
        msg:''
    },
    filters: {
      capitalize: function (value) {
        if (!value) return ''
        value = value.toString()
        return value.charAt(0).toUpperCase() + value.slice(1)
      }
    }
})


```

全局定义过滤器

```
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})


```

过滤器接收表达式的值 (msg) 作为第一个参数。capitalize 过滤器将会收到 msg的值作为第一个参数。

#### 16、一句话就能回答的面试题

**1.css只在当前组件起作用**
答：在style标签中写入**scoped**即可 例如：<style scoped></style>

**2.v-if 和 v-show 区别**
答：v-if按照条件是否渲染，v-show是display的block或none；

**3.$route和$router的区别**
答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

**4.vue.js的两个核心是什么？**
答：数据驱动、组件系统

**5.vue几种常用的指令**
答：v-for 、 v-if 、v-bind、v-on、v-show、v-else

**6.vue常用的修饰符？**
答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用

**7.v-on 可以绑定多个方法吗？**
答：可以

**8.vue中 key 值的作用？**
答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。

**9.什么是vue的计算属性？**
答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。

**10.vue等单页面应用及其优缺点**
答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

**11.怎么定义 vue-router 的动态路由? 怎么获取传过来的值**
答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。

### ============== react
#### 1. 生命周期
#### 2. 如何优化 componentShouldUpdate
#### 3. 数据如何在子父／兄弟节点中传输
#### 4. setState什么时候是同步的，什么时候是异步的  原理
#### 5. 什么是高阶组件

### ========= diff
#### 1. 什么是虚拟dom，Vnode
#### 2. diff算法实现

### =========算法
#### 1. 排序算法 

### ========= 优化
#### 1. 首屏优化

1.异步路由加载

2.不打包库文件

3.关闭sourcemap

4.开启gzip压缩

5.elementui按需加载

6.去掉console.log(),冗余的代码和组件

##### 首屏较慢的处理办法

首屏加载过慢的问题如何解决呢？
如果做完以上的优化方案，仍嫌过慢的话，可以这样做：

##### 1.loading效果

首页加个好看的loading阻塞一下，让用户别等的那么心焦。

##### 2.首页单独做服务端渲染



官方可能叫你这么引入这个库的：

```
在 main.js 引入改库
import Vue from 'vue';
import { Button, Select } from 'element-ui';
import App from './App.vue';

Vue.component(Button.name, Button);
Vue.component(Select.name, Select);
/* 或写为
 * Vue.use(Button)
 * Vue.use(Select)
 */

new Vue({
  el: '#app',
  render: h => h(App)
});

```

这种引用方式在实际引用中，会大大增加 app.js 的体积，所以，这里，我是把 elemenui 相关的引用放到相应的组件里面，以组件的形式去引用，这样，app.js 的体积会缩小很多。

然后，就是写代码的习惯了，比如引用组件，尽量用以下形式，**代替 import from** 的方式：

```
const Loading = () => import('@/components/Common/loading');
```

这种方式引入组件的好处是，**webpack 会对代码进行自动分割，异步加载组件，从而实现路由的懒加载**，**根据需求引入不同的组件**，而不是第一次加载就全部引入。

#### 2. 函数节流和函数防抖

函数防抖（debounce）其实就是通过设置定时器，让用户非常高频率触发的事件，在触发结束之后再响应，而且只执行一次，这样能非常大的提高性能。

![img](https://pics1.baidu.com/feed/95eef01f3a292df523baa458affbd86435a87354.jpeg?token=9ee91275275aaa007119b3c6560c6be6&s=21D033CA5BE497684045CC070000E0C2)

![img](https://pics6.baidu.com/feed/0824ab18972bd40763a9129568431a550eb309be.jpeg?token=177f3273ffc60c6fb1b3bc0b3b9ad18e&s=49863C7211D44DCA5CDD30CE000070B2)

实现一个防抖函数了，我们的需求是，当用户持续的输入的过程中，不触发请求，当用户完整的输入了itsource，再去触发一个请求。

我们实现的思路就是：**先设置一个计时器变量，用闭包保存，保证不会被内存释放，在事件触发的时候，也就是只要事件触发，先清除这个计时器，然后再设置一个，那么只要事件持续触发，刚刚建立的定时器就会被销毁，直到最后我们不在触发事件，就执行最后一次设置的定时器。**

防抖（debounce）实现代码如下：

![img](https://pics7.baidu.com/feed/f31fbe096b63f6246cafa5e3948e6ffc184ca3aa.jpeg?token=57ff1b3e148b4b0667454af45150835c&s=25C2B34ADAACB76C4C41440F0000A0C2)

![img](https://pics2.baidu.com/feed/d6ca7bcb0a46f21f6620be20e5eeef640d33aef8.jpeg?token=a8f25e87022a96508c9160c0b35ab0fe&s=04327532CD664D201279B4CA000030B2)

我们再快速的输入itsource的时候，只有等待itsource输入完成，才会触发一次请求，从而实现了函数防抖的效果。

**函数节流（throttle）**：函数的节流和防抖是有区别的，举个简单的例子，如果大家抢购去源码时代学习的优惠券，有一个抢购按钮，如果有些同学**疯狂点击或者使用脚本来点击这个抢购按钮**，那么，触发的频率非常的快，给后端发送的请求会非常的多，可能造成页面卡顿或者浏览器崩溃。

那么我们如何来解决这个问题呢，其实就是使用节流的思想，就像生病的时候打点滴，如果速度太快，人会受不了，这个时候，我们可以可以调整控制点滴的速度，也就是节流。

首先看一下没有节流的实例代码和效果：

![img](https://pics4.baidu.com/feed/11385343fbf2b21171bf5b29d94ae13c0dd78e17.jpeg?token=2ba2b33abdc7e8f0bad7362e6f926fc5&s=60D033C05FB4B6491E6D0C0B0000E0C0)

![img](https://pics6.baidu.com/feed/a044ad345982b2b787868df422674feb76099b37.jpeg?token=56d96a92cbc0fcb7440d4777e4a19419&s=0840E1130D22752010F484DA0000D0B2)

当快速的点击抢购按钮的时候，数量快速的增加，如果有人用脚本点击，那么这个数量会瞬间非常的大，造成性能问题。

那么我们就需要**控制触发函数的频率，也就是节流**，**事件第一次触发的时候，记录下函数执行的时间点，当函数想要再一次执行，需要间隔一定的时间才能执行，也就是每间隔一定的时间，才能触发这个函数，而不能快速触发，这就是节流的方法。**

节流实现代码和效果如下：

![img](https://pics0.baidu.com/feed/9e3df8dcd100baa1adcebf0a54da3d16cafc2eeb.jpeg?token=42058b1fefeb3d4605ac2e315cbaf7bc&s=21C0B342DAA4B76E04ED440B0000A0C0)

![img](https://pics4.baidu.com/feed/0823dd54564e92588c1f03938f48555ccdbf4ef6.jpeg?token=3563c4ff6ea4a96e51d6097c6eb76849&s=8170E1325B22752418DDE4CA0000C0B2)

现在，当我们**高频率的点击抢购按钮的时候，只有每间隔一秒，才会触发函数，不好连续的触发，从而实现了节流**。

防抖和节流都是前端性能优化重要的知识点，希望大家都能掌握如何实现，在以后的前端面试或者开发的过程中，都非常的有用哦。

#### 3. 函数curry与uncurry

### ========= 安全
#### 1. XSS CSRF

##### 1. xss

XSS，即 Cross Site Script，中译是**跨站脚本攻击**；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。

##### 3.CSRF

CSRF，即 Cross Site Request Forgery，中译是**跨站请求伪造**，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。

通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

**1.防御XSS攻击**

- **HttpOnly 防止劫取 Cookie**
- **用户的输入检查**
- **服务端的输出检查**

**2.防御CSRF攻击**

-  **验证码**
-  **Referer Check**
-  **Token 验证)**

### =========工程化
#### 1.概念： webpack gulp grunt区别

> 答案：Webpack是一个模块打包器，他可以递归的打包项目中的所有模块，最终生成几个打包后的文件。他和其他的工具最大的不同在于他支持code-splitting、模块化(AMD，ESM，CommonJs)、全局分析。

#### 2.概念：什么是Loader?什么是Plugin?

> 答案：
> 1）Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出的文件中
> 2）Plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个对象，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。

#### 3.配置问题:如何可以自动生成webpack配置？

> 答案： webpack-cli /vue-cli /etc ...脚手架工具

#### 4.开发问题一：webpack-dev-server和http服务器如nginx有什么区别?

> 答案：webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。

#### 5.开发问题二:什么 是模块热更新？

> 答案:模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。

#### 6.优化问题一：什么是长缓存？在webpack中如何做到长缓存优化？

> 答案：浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码，最方便和简单的更新方式就是引入新的文件名称。在webpack中可以在output纵输出的文件指定chunkhash,并且分离经常更新的代码和框架代码。通过NameModulesPlugin或是HashedModuleIdsPlugin使再次打包文件名不变。

#### 优化问题二：什么是Tree-shaking?CSS可以Tree-shaking吗

> 答案：Tree-shaking是指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码。在webpack中Tree-shaking是通过uglifySPlugin来Tree-shaking
> JS。Css需要使用Purify-CSS。

## VUE



### 一、介绍VUE

Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

### 二、安装cli脚手架

(1)  安装node环境

(2)  **npm install -g vue-cli**	#全局安装 vue-cli 脚手架

(3)  **vue init webpack my-project**	#创建一个基于“webpack”模板的新项目

(4)  **cd my-project**	#进入你的项目文件夹

(5)  **npm install**	#安装依赖

(6)  **npm run dev**	# 启动项目

建议采用一下配置构建空项目：

```
**? Project name vue**
**? Project description A Vue.js project**
**? Author luzhaoqi <1031880547@qq.com>**
**? Vue build standalone**
**? Install vue-router? Yes**
**? Use ESLint to lint your code? Yes**
**? Pick an ESLint preset Standard**
**? Set up unit tests No**
**? Setup e2e tests with Nightwatch? No**
**? Should we run `npm install` for you after the project has been created? (recommended) npm**

```



**！！！建议加入eslint提高代码质量！！！**

### 三、配置什么

(1)安装一些的依赖

```
npm install less less-loader --save-dev
npm install px2rem-loader amfe-flexible --save-dev
npm install sass-resources-loader --save-dev

npm install axios
npm install vuex
npm install better-scroll
npm install vue-lazyload
npm install good-storage
npm install fastclick

```

(2)修改.eslintrc.js

增加如下规则

```
rules: {
    'generator-star-spacing': 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'arrow parens': 0,
    'eol-last': 0,
    'space-before-function-paren': 0,
    'no-multi-spaces': 1,
    'indent': 0,
    'no-undef': 0
  }

```

(3)修改build/webpack.base.conf

```
alias: {
  'vue$': 'vue/dist/vue.esm.js',
  '@': resolve('src'),
  'common': resolve('src/common'),
  'components': resolve('src/components'),
  'base': resolve('src/base'),
  'api': resolve('src/api')
}

```

将 test: /\.(png|jpe?g|gif|svg)(\?.*)?$/  代码后的limit改为

```
limit: 1000000 //根据项目来调整大小

```

(4)修改.build/utils.js

exports.cssLoaders代码下增加

```
 // rem
 const px2remLoader = {
    loader: 'px2rem-loader',
    options: {
      remUnit: 100
    }
  }
  // 全局sass变量
  function lessResourceLoader() {
    var loaders = [
      cssLoader,
      'less-loader',
      {
        loader: 'sass-resources-loader',
        options: {
          resources: [
            // 此处地址指向配置less变量的文件
            path.resolve(__dirname, '../src/common/css/theme.less'),
          ]
        }
      }
    ];
    if (options.extract) {
      return ExtractTextPlugin.extract({
        use: loaders,
        fallback: 'vue-style-loader'
      })
    } else {
      return ['vue-style-loader'].concat(loaders)
    }
  }

```

将：

```
const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]

```

改为：

```
const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]

```

将：

```
less: generateLoaders('less')

```

改为：

```
less: lessResourceLoader('less')

```

(5).修改config/index.js

```
proxyTable: {
    '/': {
      target: 'http://你的线上网址.com',
      changeOrigin: true,
      pathRewrite: {
        '^/': ''
      }
    }
  }

```

要有全局sass变量

### 四、生命周期钩子

**beforeCreate**:实例刚在内存中被创建出来，此时还没有初始化好 data 和 methods 属性(**一般不用**)

**created**:实例已经在内存中创建OK，此时 data 和 methods 已经创建OK（**这时可以调用异步请求，和初始化一些数据**）

**beforeMound**:此时已经完成了模板的编译，但是还没有挂载到页面中(**一般不用**)

**mounted**:此时，已经将编译好的模板，挂载到了页面指定的容器中显示（**写操作页面的方法**）

**beforeUpdate**:状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点（**一般不用**）

**updata**:实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！（**一般不用**）

**befoeDestory**:实例销毁之前调用。在这一步，实例仍然完全可用。（**一般不用**）

**destoryed**:实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 （**一般用于清除定时，释放内存**）

**除此之外，在说一些别的：**

**data**:存放数据的

**computed**:计算属性，跟据data中的某些数据得到一个新的数据

**filters**:过滤器,类似于computed

**methods**:写方法的，最简单的根据一个数据拼接成另一个数据就直接写在computed中就好了

**watch**:监听数据变化的(**很重要，我个人用的还是比较多的**)。例如某个数据变化了，我需要重新计算元素的高度，或者去改变别的数据

### 五、vue-router

```
  import Vue from 'vue'
  import Router from 'vue-router'

  Vue.use(Router)
  export default new Router({
    routes: [
      {
        path: '*',
        redirect: '/learn' // 404
      },
      {
        path: '/',
        redirect: '/learn' // 重定向
      },
      {
        path: '/learn',
        name: 'Learn',
        component: resolve => require(['components/learn/learn'], resolve)
      },
      {
        path: '/life',
        name: 'Life',
        component: resolve => require(['components/life/life'], resolve),
        children: [
          {
            path: ':id/:type',
            name: 'LifeContent',
            component: resolve => require(['components/content/content'], resolve)
          }
        ],
        beforeEnter: (to, from, next) => {
          console.log(to)
          console.log(from)
          console.log(next)
        }
      },
      {
        path: '/content/:id',
        name: 'Content',
        component: resolve => require(['components/content/content'], resolve)
      }
    ]
  })

```

建议路由用这种resolve的形式来异步加载组件，提升网页加速速度，

并适当的使用**keep-alive**标签

```
    // 路由守卫，有兴趣的自己看看
    beforeRouteEnter(to, from, next) {
      console.log(this, 'beforeRouteEnter') // undefined
      console.log(to, '组件独享守卫beforeRouteEnter第一个参数')
      console.log(from, '组件独享守卫beforeRouteEnter第二个参数')
      console.log(next, '组件独享守卫beforeRouteEnter第三个参数')
      next(vm => {
        // 因为当钩子执行前，组件实例还没被创建
        // vm 就是当前组件的实例相当于上面的 this，所以在 next 方法里你就可以把 vm 当 this 来用了。
        console.log(vm)// 当前组件的实例
      })
    },
    beforeRouteUpdate(to, from, next) {
      // 在当前路由改变，但是该组件被复用时调用
      // 对于一个带有动态参数的路径 /good/:id，在 /good/1 和 /good/2 之间跳转的时候，
      // 由于会渲染同样的good组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例 `this`
      console.log(this, 'beforeRouteUpdate') // 当前组件实例
      console.log(to, '组件独享守卫beforeRouteUpdate第一个参数')
      console.log(from, '组件独享守beforeRouteUpdate卫第二个参数')
      console.log(next, '组件独享守beforeRouteUpdate卫第三个参数')
      next()
    },
    beforeRouteLeave(to, from, next) {
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例 `this`
      console.log(this, 'beforeRouteLeave') // 当前组件实例
      console.log(to, '组件独享守卫beforeRouteLeave第一个参数')
      console.log(from, '组件独享守卫beforeRouteLeave第二个参数')
      console.log(next, '组件独享守卫beforeRouteLeave第三个参数')
      next()
    }

```

### 六、vuex

建议在src下建立store文件夹，文件夹下有如下文件：

(1).index.js

```
// 入口文件
import Vue from 'vue'
import Vuex from 'vuex'
import * as actions from './actions'
import * as getters from './getters'
import state from './state'
import mutations from './mutations'
import createLogger from 'vuex/dist/logger'

Vue.use(Vuex)

const debug = process.env.NODE_ENV !== 'production'

export default new Vuex.Store({
  actions,
  getters,
  state,
  mutations,
  strict: debug,
  plugins: debug ? [createLogger()] : []
})


```



(2).state.js

```
// 所有状态
import {loadSearch, loadArticle} from 'common/js/cache'

const state = {
  searchHistory: loadSearch(), // 搜索历史
  articleHistory: loadArticle()
}
export default state


```

(3).getter.js

```
// 获取state
export const searchHistory = state => state.searchHistory
export const articleHistory = state => state.articleHistory

```

(4).mutation-type.js

```
// 存储mutation 常量
export const SET_SEARCH_HISTORY = 'SET_SEARCH_HISTORY'
export const SET_ARTICLE_HISTORY = 'SET_ARTICLE_HISTORY'

```

(5).mutations.js

```
// 定义修改操作
import * as types from './mutation-types'

const mutations = {
  [types.SET_SEARCH_HISTORY](state, history) {
    state.searchHistory = history
  },
  [types.SET_ARTICLE_HISTORY](state, history) {
    state.articleHistory = history
  }
}
export default mutations

```

(6).action.js

```
// 异步修改
import * as types from './mutation-types'
import {saveSearch, deleteSearch, clearSearch, saveArticle, clearArticle} from 'common/js/cache'

export const saveSearchHistory = function ({commit}, query) {
  commit(types.SET_SEARCH_HISTORY, saveSearch(query))
}
export const deleteSearchHistory = function ({commit}, query) {
  commit(types.SET_SEARCH_HISTORY, deleteSearch(query))
}
export const clearSearchHistory = function ({commit}) {
  commit(types.SET_SEARCH_HISTORY, clearSearch())
}

export const saveArticleHistory = function ({commit}, item) {
  commit(types.SET_ARTICLE_HISTORY, saveArticle(item))
}
export const delSearchHistory = function ({commit}) {
  commit(types.SET_ARTICLE_HISTORY, clearArticle())
}

```

**不建议用以下写法：**

**this.$store.commit('mutations方法名',值)**

**this.$store.dispatch('mutations方法名',值)**

### 四、项目文件夹介绍

static目录下的代码不会被压缩，所有vue文件都应该放在src目录下：

src

└─ api	数据接口文件夹

│   ├─ api.js	数据接口

│   └─ config.js	接口配置项

├─ base	基础组件文件夹

│   └─ xxx	xxx组件文件夹

│        └─  -xxx.vue	xxx组件.vue

├─ common	放基础文件的文件夹

│   └─ css	基础css文件夹

│   └─fonts	基础字体文件夹

│   └─ images	基础图片文件夹

│   └─ js	基础js文件夹

├─ components	路由组件文件夹一个地址一个文件夹（大组件）

│   └─ xxx	组件文件夹

│        └─  -xxx.vue	xxx组件.vue

├─ router	路由信息组件文

│   └─ index.js	路由信息

├─ store	vuex数据文件夹

│   └─ index.js	vuex配置文件

│   └─ state.js	vuex中存贮的数据

│   └─ getters.js	获取state

│   └─ mutation-types.js	存储mutation 常量

│   └─ mutations.js	 定义修改state的方法

│   └─ actions.js	提交mutation来修改数据

├─ App.vue	主页 开始的地方

└─ main.js	配置和加载一些资源 然后周到App.vue中

### 七、打包上线

修改config/index.js

build下的代码：

```
// TP3.2网页版本的配置
index: path.resolve(__dirname, '../../Application/home/View/index/index.html'),
assetsRoot: path.resolve(__dirname, '../../Public/home'),
assetsSubDirectory: 'static',
assetsPublicPath: '/public/home/',
// 打包app的配置
// index: path.resolve(__dirname, '../dist/index.html'),
// assetsRoot: path.resolve(__dirname, '../dist'),
// assetsSubDirectory: 'static',
// assetsPublicPath: '',

```

**配置根据自己实际项目来配置**

**这里提供了一个TP3.2框架的配置和APP的配置**

cmd中执行 **npm run build**

### 八、代码性能优化

(1).加入eslint提高代码质量(代码规范)

(2).抽基本组件(使功能和业务分离)

(3).异步按需加载组件，缓存组件(提高一开始的加载速度)

(4).控制每个vue文件不超过 **300** 行代码(逻辑简单好维护)

(5).使用mixin(代码瘦身)

(6).提取公共的ajax异步请求(代码瘦身)

```javascript
// 公共的post方法
function post(url, data) {
  if (!data) {
    data = []
  }
  var params = new URLSearchParams()
  for (var i in data) {
    params.append(i, data[i])
  }
  return axios.post(www + url, params).then((res) => {
    return Promise.resolve(res.data)
  })
}

// 公共的get方法
function get(url, data) {
  return axios.get(www + url, {
    params: data
  }).then((res) => {
    return Promise.resolve(res.data)
  })
}
// search方法
export function search(search, next, num) {
  const url = '/article/search'
  const data = Object.assign({}, commonParams, {
    search,
    next,
    num
  })
  return post(url, data)
}

```

(7).使用模块化的vuex(小项目用不到)

## HTML5

### 什么是HTML

HTML是Hypertext Markup Language的英文缩写，即超文本标记语言（或谓超文本置标语言），是一种用来制作网页的标记语言，是WWW的描述语言. HTML语言是一种标记语言，它不需要编译，可以直接由浏览器执行（属于浏览器解释型语言）。

### 1、新的 HTML5 文档类型和字符集是？

HTML5 文档类型很简单：

| 1    | <!doctype  html> |
| ---- | ---------------- |
|      |                  |

HTML5 使用 UTF-8 编码示例：

| 1    | <meta  charset=”UTF-8″> |
| ---- | ----------------------- |
|      |                         |

### 2、HTML5 中如何嵌入音频？

HTML5 支持 MP3、Wav 和 Ogg 格式的音频，下面是在网页中嵌入音频的简单示例：

| 1  2  3  4 | <audio  controls>      <source  src=”jamshed.mp3″ type=”audio/mpeg”>      Your  browser does’nt support audio embedding feature.  </audio> |
| ---------- | ---------------------------------------- |
|            |                                          |

### 3、HTML5 中如何嵌入视频？

和音频类似，[**HTML5**](http://www.cnblogs.com/lhb25/category/146076.html) 支持 MP4、WebM 和 Ogg 格式的视频，下面是简单示例：

| 1  2  3  4 | <video  width=”450″ height=”340″ controls>    <source  src=”jamshed.mp4″ type=”video/mp4″>     Your  browser does’nt support video embedding feature.  </video> |
| ---------- | ---------------------------------------- |
|            |                                          |

### 4、除了 audio 和 video，HTML5 还有哪些媒体标签？

[**HTML5**](http://www.yyyweb.com/tag/html5) 对于多媒体提供了强有力的支持，除了 audio 和 video 标签外，还支持以下标签：

<embed> 标签定义嵌入的内容，比如插件。

| 1    | <embed type=”video/quicktime”  src=”Fishing.mov”> |
| ---- | ---------------------------------------- |
|      |                                          |

<source> 对于定义多个数据源很有用。

| 1  2  3  4 | <video  width=”450″ height=”340″ controls>       <source  src=”jamshed.mp4″ type=”video/mp4″>       <source  src=”jamshed.ogg” type=”video/ogg”>  </video> |
| ---------- | ---------------------------------------- |
|            |                                          |

<track> 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。

| 1  2  3  4  5  6 | <video  width=”450″ height=”340″ controls>       <source  src=”jamshed.mp4″ type=”video/mp4″>       <source  src=”jamshed.ogg” type=”video/ogg”>       <track  kind=”subtitles” label=”English” src=”jamshed_en.vtt” srclang=”en”  default></track>        <track  kind=”subtitles” label=”Arabic” src=”jamshed_ar.vtt”  srclang=”ar”></track>  </video> |
| ---------------- | ---------------------------------------- |
|                  |                                          |

### 5、HTML5 Canvas 元素有什么用？

Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 [**HTML**](http://www.cnblogs.com/lhb25/category/146076.html) 上进行图形操作，

| 1  2 | `<canvas  id=”canvas1″ width=”300″ height=”100″>`  `</canvas>` |
| ---- | ---------------------------------------- |
|      |                                          |

- [不可思议的     HTML5 Canvas 应用试验](http://www.cnblogs.com/lhb25/p/html5-canvas-demos.html)
- [18个基于 HTML5     Canvas 的图表库](http://www.cnblogs.com/lhb25/archive/2011/04/12/1964343.html)
- [20个惊艳的     HTML5 Canvas 应用试验](http://www.cnblogs.com/lhb25/archive/2012/05/29/impressive-html5-canvas-experiments.html)
- [16款 HTML5     Canvas 开发的网页游戏](http://www.cnblogs.com/lhb25/archive/2011/03/27/1993819.html)
- [推荐14款强大的HTML5素描及绘图工具](http://www.cnblogs.com/lhb25/archive/2011/03/12/1964298.html)

### 6、HTML5 存储类型有什么区别？

HTML5 能够本地存储数据，在之前（html4）都是使用 cookies 使用的。[**HTML5**](http://www.yyyweb.com/tag/html5) 提供了下面两种本地存储方案：

- **localStorage **用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。
- **sessionStorage **同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储

### 7、HTML5 有哪些新增的表单元素？

HTML5 新增了很多表单元素让开发者构建更优秀的 Web 应用程序。

- datalist
- datetime
- output
- keygen 
- date 
- month 
- week
- time
- color
- number 
- range 
- email 
- url

### 8、HTML5 废弃了哪些 HTML4 标签？

HTML5 废弃了一些过时的，不合理的 [**HTML**](http://www.yyyweb.com/tag/html5) 标签：

- frame
- frameset
- noframe
- applet
- big
- center
- basefront

### 9、HTML5 标准提供了哪些新的 API？

HTML5 提供的应用程序 API 主要有：

- Media API
- Text Track API
- Application Cache API
- User Interaction
- Data Transfer API
- Command API
- Constraint Validation API
- History API

### 10、HTML5 应用程序缓存和浏览器缓存有什么区别？

应用程序缓存是 [**HTML5**](http://www.yyyweb.com/tag/html5) 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如HTML、CSS、图片以及JavaScript。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：

| 1  2  3  4 | `<!doctype  html>`  `<html manifest=”example.appcache”>`  `…..`  `</html>` |
| ---------- | ---------------------------------------- |
|            |                                          |

与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。

### 11.block，inline和inline-block概念和区别

##### 1.总体概念

block和inline这两个概念是简略的说法，完整确切的说应该是 block-level elements (块级元素) 和 inline elements (内联元素)。block元素通常被现实为独立的一块，会单独换一行；inline元素则前后不会产生换行，一系列inline元素都在一行内显示，直到 该行排满。

大体来说HTML元素各有其自身的布局级别（block元素还是inline元素）： 

常见的块级元素有 DIV, FORM, TABLE, P, PRE, H1~H6,DL, OL, UL 等。

常见的内联元素有 SPAN, A,STRONG, EM, LABEL, INPUT, SELECT, TEXTAREA, IMG, BR 等。

block元素可以包含block元素和inline元素；但inline元素只能包含inline元素。要注意的是这个是个大概的说法，每个特定的元素能包含的元素也是特定的，所以具体到个别元素上，这条规律是不适用的。比如 P 元素，只能包含inline元素，而不能包含block元素。

一般来说，可以通过display:inline和display:block的设置，改变元素的布局级别。

##### 2.block，inline和inlinke-block细节对比

###### display:block

block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。

block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。

block元素可以设置margin和padding属性。

###### display:inline

inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。

inline元素设置width,height属性无效。

inline元素的margin和padding属性，水平方向的padding-left,padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。

###### display:inline-block

 

简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。

##### 3.补充说明

一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。

IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE 是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline- block属性的表象。

 

### SVG 动画的 JavaScript 库

SVG 是一种分辨率无关的图形（矢量图形）。这意味着它在任何类型的屏幕都不会遭受任何质量损失。除此之外，你可以让[**SVG**](http://www.cnblogs.com/lhb25/category/146074.html) 灵活现一些动画效果。这篇文章就给大家推荐8个实现 SVG 动画的JavaScript 库

### vw和vh单位的大小是多少？

vw和vh是根据设备的宽度和高度来决定的，设备的宽就是100vw，设备的高就是100vh，
你设置的50vw就是相当于设备宽度的50%，你设置的100vh就是相当于设备高度的100%。

一般情况下笔者宽度，和字体大小，左右边距间距等都是用vw单位，
高度，行高，上下边距间距等都是用vh单位。

##  JS

### 函数声明、函数表达式及匿名函数的形式、立即执行函数

![img](C:/Ynote/m18360916413_1@163.com/ffcd2dbb55224799ab87d261b46d8c28/2f65d08a92f74582a4d54fd7655587e7.jpeg)

接下来看立即执行函数的两种常见形式：( function(){…} )()和( function (){…} () )，一个是一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号，另一个是一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中，这两种写法是等价的。要想立即执行函数能做到立即执行，要注意两点，一是函数体后面要有小括号()，二是函数体必须是函数表达式而不能是函数声明。先看下图：

![img](C:/Ynote/m18360916413_1@163.com/3d489ad9bb4d4360bdbf2a39625bcb28/0d949047ba4d47df97fc8bf582fa2300.jpeg)

### 1.截取字符串abcdefg的efg

### 2.判断一个字符串中出现次数最多的字符，统计这个次数
```
/*var str =
'asdfssaaasasasasaa';
var json = {};
for (var i = 0; i < str.length; i++) {
        if(!json[str.charAt(i)]){
                json[str.charAt(i)] =
1;
        }else{
                json[str.charAt(i)]++;
        }
}
var iMax = 0;
var iIndex = '';
for(var i in json){
        if(json[i]>iMax){
                iMax = json[i];
                iIndex = i;
        }
}
alert('出现次数最多的是:'+iIndex+'出现'+iMax+'次');*/

```

 

### 3.IE与FF脚本兼容性问题

### 4.请尽可能详尽的解释AJAX的工作原理

1.创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）

2.判断数据传输方式(GET/POST)
3.打开链接 open()
4.发送 send()
5.当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数

### 5.你能解释一下JavaScript中的继承是如何工作的吗

子构造函数中执行父构造函数，并用call\apply改变this.

XX.Call(this,object,克隆父构造函数原型上的方法

### 6.你如何优化自己的代码？

1.代码重用
2.避免全局变量（命名空间，封闭空间，模块化mvc..）
3.拆分函数避免函数过于臃肿
4.注释

### 7.你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？

对内：模块模式
对外：继承

### 8..请解释什么是Javascript的模块模式，并举出实用实例。

js模块化mvc（数据层、表现层、控制层）

seajs
命名空间

### 9..文档类型的作用是什么？你知道多少种文档类型？      

影响浏览器对html代码的编译渲染
html2.0
xHtml
html5

Doctype来区分

### 10.浏览器标准模式和怪异模式之间的区别是什么

 //盒模型解释不同

### 11.你使用过那些Javascript库

jquery 

Seajs

yui

### 12.哈希表

//具有散列（映射）特性的数据模型

13.闭包

子函数能被外部调用到，则该作用连上的所有变量都会被保存下来。

 

### 14.你能描述一下你制作一个网页的工作流程吗？ 

### 15.你能描述一下渐进增强和优雅降级之间的不同吗?

### 16 请解释一下什么是语义化的HTML

//内容使用特定标签，通过标签就能大概了解整体页面的布局分

### 17.你如何对网站的文件和资源进行优化？ 

### 19. 为什么利用多个域名来存储网站资源会更有效？

确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站
20.请说出三种减低页面加载时间的方法

1、 压缩css、js文件

2、 合并js、css文件，减少http请求

3、 外部js、css文件放在最底下

4、 减少dom操作，尽可能用变量替代不必要的dom操作*/

### 21.什么是FOUC？你如何来避免FOUC？

 /*由于css引入使用了@import 或者存在多个style标签以及css文件在页面底部引入使得css文件加载在html之后导致页面闪烁、花屏
用link加载css文件，放在head标签里面*/

### 22.编写一个方法 求一个字符串的字节长度;

 //假设一个中文占两个字节
/*var str = '22两是';
alert(getStrlen(str))
function getStrlen(str){
​        var json = {len:0};
​        var re = /[\u4e00-\u9fa5]/;
​        for (var i = 0; i < str.length; i++) {
if(re.test(str.charAt(i))){
  json['len']++;
​                }
​        };
​        return json['len']+str.length;
}*/
23.编写一个方法
去掉一个数组的重复元素

/*var arr = [1,2,3,1,43,12,12,1];
var json = {};
var arr2 = [];
for (var i = 0; i < arr.length; i++) {
​        if(!json[arr[i]]){
​                json[arr[i]] = true;
​        }else{
​                json[arr[i]] = false;
​        }
​        if(json[arr[i]]){
​                arr2.push(arr[i]);
​        }
};
for (var i = 0; i < arr.length; i++) {
​        if(!aa(arr[i], arr2)){
​                arr2.push(arr[i])
​        }
};
function aa(obj, arr){
​        for (var i = 0; i < arr.length; i++) {
​                if(arr[i] == obj)
return true;
​                else return false;
​        };
}
alert(arr2)*/

### 23.写出3个使用this的典型应用

/*
事件：
如onclick  this->发生事件的对象
构造函数          this->new 出来的object
call/apply        改变this*/

### 24.如何深度克隆

/*var arr = [1,2,43];
var json = {a:6,b:4,c:[1,2,3]};
var str = 'sdfsdf';
var json2 = clone(json);
alert(json['c'])
function clone(obj){
​        var oNew = new obj.constructor(obj.valueOf());
​        if(obj.constructor == Object){
​                for(var i in obj){
  oNew[i] = obj[i];
  if(typeof(oNew[i]) == 'object'){
​          clone(oNew[i]);
  }
​                }
​        }
​        return oNew;
}*/

### 25.JavaScript中如何检测一个变量是一个String类型？请写出函数实现

// typeof(obj) == 'string'
// obj.constructor == String;

### 26，网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示“××年还剩××天××时××分××秒”

 /*var oDate = new Date();
var oYear = oDate.getFullYear();
var oNewDate = new Date();
oNewDate.setFullYear(oYear, 11, 31, 23, 59, 59);
var iTime = oNewDate.getTime()-oDate.getTime();
var iS = iTime/1000;
var iM = oNewDate.getMonth()-oDate.getMonth();
var iDate =iS*/****

## 浏览器

### 一、三种会话机制

#### Application全局会话

网站程序从运行到结束，会话数据放在服务器中

#### session链接会话

比application程序弱一点，，从访问到访问结束，session会话可以清除，会话数据存放在服务器中.一般保存整个项目中常用的数据：用户编号，用户其他信息等常用信息。

#### Cookie链接会话

从创建cookies开始到访问结束，cookies存放到客户端，安全性低

一般保持敏感数据，手动让cookies失效，设置cookie时间在创建时间之前.

一般保存临时的不重要的信息：验证码（容易失效），一个页面跳转到另外一个页面传递的信息。

#### JSON数据格式

本质：字符串

**{[key1:”values1”,”key2”:”value2”,”key3”:”[{“key31”:”value31”}]”,{“key32”:”value32”}]}**

**键值对格式******

## react

### 一、常用api链接

https://pro.ant.design/docs/getting-started-cn
React：https://zh-hans.reactjs.org/
基础：https://juejin.im/post/5d817a15f265da039929a761
新特性：https://juejin.im/post/5d6383d0f265da03b638b919
Redux：https://juejin.im/post/5d3e3c42e51d45590a445c37
有一个特别全的列表我找不到了，找到了我再发一下吧。

-----------------------------------------
脚手架：
Antd pro官网：https://pro.ant.design/index-cn
Github：https://github.com/ant-design/ant-design-pro/blob/master/README.zh-CN.md
预览：http://preview.pro.ant.design
首页：http://pro.ant.design/index-cn
使用文档：http://pro.ant.design/docs/getting-started-cn
更新日志: http://pro.ant.design/docs/changelog-cn
常见问题：http://pro.ant.design/docs/faq-cn
国内镜像：http://ant-design-pro.gitee.io

umi：
https://umijs.org/zh/
https://github.com/umijs/umi/blob/master/README_zh-CN.md

dva：
https://dvajs.com/
https://github.com/dvajs/dva/blob/master/README_zh-CN.md

-------------------------------------------
代码规范（需插件辅助，保证所有人提交到git的代码风格完全一致，但是也要熟悉规范）：

React/CSS-in-JavaScript/CSS & Sass的规范：
https://lin-123.github.io/javascript/
https://github.com/lin-123/javascript

JSX规范：
https://github.com/JasonBoy/javascript/tree/master/react



### 二、  命令安装环境

```
确保电脑上已经安装了nodejs,再用用yarn-1.19.msi安装yarn
1.安装node.js

2.安装npm,安装cnpm
  npm install -g cnpm --registry=https://registry.npm.taobao.org
  
3.安装yarn
  npm install yarn -g --save
  
4 安装tyarn  国内源
  cnpm i yarn tyarn -g
  tyarn -v
5 安装umi
  tyarn global add umi
  将yarn路径配置到环境变量的path
  umi -v
6.安装静态服务
  cnpm install -g serve
  
7.reate-react-app
  npm install -g create-react-app
  
   create-react-app是React官方出的脚手架工具，其实有很多第三方的脚手架工具
```

### 三、本地开发

创建项目文件夹，再该目录执行以下命令

#### 1).官方脚手架开发

```
D:  //进入D盘
mkdir ReactDemo  //创建ReactDemo文件夹
create-react-app demo01   //用脚手架创建React项目
cd demo01   //等创建完成后，进入项目目录
npm start   //预览项目，如果能正常打开，说明项目创建成功
npm install antd --save  or  yarn add antd  //安装AntDesign
```

#### 2).umi-antD-dva开发

```
umi，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。
可以借助umi创建一个antD空项目

yarn/tyarn create umi
or
cnpm create umi

Choose `ant-design-pro`--->语言：javascript

安装依赖
yarn install
启动
yarn start
umi ui
```

#### 3).目录介绍

- **package.json**: 这个文件是`webpack`配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置。
- **package-lock.json**：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再`npm install` 时大家的依赖能保证一致
- **node_modules** :这个文件夹就是我们项目的依赖包
- **public** ：公共文件，里边有公用模板和图标等一些东西。
- **src** ： 主要代码编写文件

### 四、react基础

ReactDom

https://www.jianshu.com/p/92a0c5933964

index.js

```
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
ReactDOM.render(<App />,document.getElementById('root'))
```

#### 1. 使用脚手架开发的项目的特点

```
模块化: js是一个一个模块编写的
组件化: 界面是由多个组件组合编写实现的
工程化: 实现了自动构建/运行/打包的项目
```

#### 2. 组件化编写项目的流程

```
拆分组件
实现静态组件--->静态页面
实现动态组件
	动态显示初始化数据
	交互
```

#### 3. app1: 实现一个评论管理功能

##### 1). 拆分组件:

```
应用组件: App
添加评论组件: CommentAdd
评论项组件: CommentItem
评论列表组件: CommentList
```

##### 2). 确定组件的state和props:

```
App: 
	* state: comments/array
CommentAdd
	* state: username/string, content/string
	* props: add/func
commentList
  	* props: comments/array, delete/func
CommentItem
	* props: comment/object, delete/func, index/number
```

#### 4. 编写静态组件

```
拆分页面
拆分css
```

#### 5. 实现动态组件

```
1. 动态展示初始化数据
  * 初始化状态数据
  * 传递属性数据
2. 响应用户操作, 更新组件界面
  * 绑定事件监听, 并处理
  * 更新state
```

#### 6. app2: 实现github用户搜索功能

##### 1). react应用中的ajax请求

```
axios: 包装XMLHttpRequest对象, promise风格, 支持浏览端/node服务器端
fetch: 浏览器内置语法, promise风格, 老浏览器不支持, 可以引入fetch.js兼容包
```

##### 2). 拆分组件

```
App
	* state: searchName/string
Search
  	* props: setSearchName/func
List
  	* props: searchName/string
  	* state: firstView/bool, loading/bool, users/array, errMsg/string
```

##### 3). 编写组件

```
编写静态组件
编写动态组件
	componentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax
	使用axios库发送ajax请求
```

#### 7. 组件间通信总结

##### 1). 方式一: 通过props传递

```
共同的数据放在父组件上, 特有的数据放在自己组件内部(state)
一般数据-->父组件传递数据给子组件-->子组件读取数据
函数数据-->子组件传递数据给父组件-->子组件调用函数
问题: 多层传递属性麻烦, 兄弟组件通信不方便
```

##### 2). 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制

```
工具库: PubSubJS
下载: npm install pubsub-js --save
使用: 
  import PubSub from 'pubsub-js' //引入
  PubSub.subscribe('delete', function(msg, data){ }); //订阅
  PubSub.publish('delete', data) //发布消息
优点: 可以支持任意关系组件之间的通信
```

##### 3). 事件监听理解

```
1. DOM事件
	* 绑定事件监听
		* 事件名(类型): 只有有限的几个, 不能随便写
		* 回调函数
	* 用户操作触发事件(event)
		* 事件名(类型)
		* 数据
2. 自定义事件
	* 绑定事件监听
		* 事件名(类型): 任意
		* 回调函数: 通过形参接收数据, 在函数体处理事件
	* 触发事件(编码)
		* 事件名(类型): 与绑定的事件监听的事件名一致
		* 数据: 会自动传递给回调函数
```



#### 8. 高级：PropTypes 传值类型校验

父组件给子组件传值，子组件通过this.props获取，类型校验要引用都proptypes,

```
//安装
npm install prop-types --save
//引入
import PropTypes from 'prop-types';
```

现在子组件引入

再在子组件方法下面添加

是子组件的最下面

```jsx
//定义传值类型
xxx.propTypes={
    aaa:PropTypes.string
}
//默认值
xxx.defaultProps={
    aaa:'213'
}
```

#### 9.React生命周期

```
生命周期函数指在某一个时刻组件会自动调用执行的函数
```

##### 1).Initialization:初始化阶段。

##### 2).Mounting: 挂在阶段。

Mounting阶段叫挂载阶段，伴随着整个虚拟DOM的生成，它里边有三个小的生命周期函数，分别是：
componentWillMount : 在组件即将被挂载到页面的时刻执行。
render : 页面state或props发生变化时执行。
componentDidMount : 组件挂载完成时被执行。

##### 3).Updation: 更新阶段。

```text
1-shouldComponentUpdate---组件发生改变前执行
2-componentWillUpdate---组件更新前，shouldComponentUpdate函数之后执行
3-render----开始挂载渲染
4-componentDidUpdate----组件更新之后执行
```

##### 4).Unmounting: 销毁阶段

```
componentWillUnmount它是在组件去除时执行。
```

##### 5）.TODOList性能优化

在子组件选择性的判断是否更新组件

```js
shouldComponentUpdate(){  
     if(...){
      return true;
    }else{
       return false;
     }
}
```

### 五、redux中间件

#### redux-thunk中间件

```
npm install --save redux-thunk
```

##### 安装配置

1. 引入**applyMiddleware**,如果你要使用中间件，就必须在redux中引入applyMiddleware.

   ```
   import { createStore , applyMiddleware } from 'redux'
   ```

2. 引入**redux-thunk**库

   ```
   import thunk from 'redux-thunk'
   ```

3. **增强函数compose**

   ```jsx
   import { createStore , applyMiddleware ,compose } from 'redux'  //  引入createStore方法
   import reducer from './reducer'    
   import thunk from 'redux-thunk'

   //增强函数相当于链式函数
   const composeEnhancers =   window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?
   ​    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}):compose

   const enhancer = composeEnhancers(applyMiddleware(thunk))
   const store = createStore( reducer, enhancer) // 创建数据存储仓库，只能传两个参数

   export default store   //暴露出去
   ```

可以看出来redux-thunk最重要的思想，就是可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。
 正因为这个action creator可以返回一个函数，那么就可以在这个函数中执行一些异步的操作。
 例如：

```jsx
export function addCount() {
  return {type: ADD_COUNT}
} 
export function addCountAsync() {
  return dispatch => {
    setTimeout( () => {
      dispatch(addCount())
    },2000)
  }//欢迎加入全栈开发交流圈一起学习交流：864305860
}//面向1-3年前端人员
```

#### redux-saga中间件 (dva融合了saga)

### 六、Redux  的provider,connect

#### 1.`<Provider>`提供器讲解

#### 2.`connect`连接器的使用

```
npm install --save react-redux
npm install --save redux
store.dispatch(action)


```

### 七、react新特性hook

Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。

#### useState

```javascript
import React, { useState } from 'react';
function Example(){
    const [ count , setCount ] = useState(0);
    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={()=>{setCount(count+1)}}>click me</button>
        </div>
    )
}
export default Example;
```

useState不能在if...else...这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。如果你还是不理解，你可以记住这样一句话就可以了：就是React Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序。

#### useEffect两个注意点

1.React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。

2.useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。

### 八、react-router

```
npm install --save react-router-dom

import { BrowserRouter as Router, Route, Link } from "react-router-dom"

```

### 九、react-transition-group（动画库）

由三个基本的核心库组成

```
npm install react-transition-group --save

```

#### 1).Transition

#### 2).CSSTransition

- xxx-enter: 进入（入场）前的CSS样式；
- xxx-enter-active:进入动画直到完成时之前的CSS样式;
- xxx-enter-done:进入完成时的CSS样式;
- xxx-exit:退出（出场）前的CSS样式;
- xxx-exit-active:退出动画知道完成时之前的的CSS样式。
- xxx-exit-done:退出完成时的CSS样式。

#### 3).TransitionGroup

   给多个dom同时添加动画

```jsx
<ul ref={(ul)=>{this.ul=ul}}>
    <TransitionGroup>
    {
        this.state.list.map((item,index)=>{
            return (
                <CSSTransition
                    timeout={1000}
                    classNames='boss-text'
                    unmountOnExit
                    appear={true}
                    key={index+item}  
                >
                    <XiaojiejieItem 
                    content={item}
                    index={index}
                    deleteItem={this.deleteItem.bind(this)}
                    />
                </CSSTransition>
            )
        })
    }
    </TransitionGroup>
</ul>  
```



### 十、调试工具

**React developer tools**

**Redux Dev Tools**

配置`Redux Dev Tools`

```
window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()

```

### 十一、项目打包运行

```
npm run build  //生成打包文件
npm install -g serve  //全局下载服务器包
serve build  //通过服务器命令运行打包项目
访问: http://localhost:5000  //浏览器访问
```



## Npm命令常识

### npm install -save 和 -save-dev

- `npm install xxx`: 安装项目到项目目录下，不会将模块依赖写入`devDependencies`或`dependencies`。
- `npm install -g xxx`: `-g`的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 `npm cinfig prefix`的位置
- `npm install -save xxx`：`-save`的意思是将模块安装到项目目录下，并在`package`文件的`dependencies`节点写入依赖。
- `npm install -save-dev xxx`：`-save-dev`的意思是将模块安装到项目目录下，并在`package`文件的`devDependencies`节点写入依赖。

作为一个前端，要清楚的知道`npm install`这四种用法，防止项目依赖错误，在别人下载你的代码没办法跑起来。

## Axios(axios,ajax,fetch区别)

***Axios* 是一个基于 promise 的 HTTP 库,可以用在浏览器和 node.js 中**

```
npm install -save axios
```

### 原生ajax
```
    //创建异步对象  
    var xhr = new XMLHttpRequest();
    //设置请求基本信息，并加上请求头
    xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
    xhr.open('post', 'test.php' );
    //发送请求
    xhr.send('name=Lan&age=18');
    xhr.onreadystatechange = function () {
        // 这步为判断服务器是否正确响应
      if (xhr.readyState == 4 && xhr.status == 200) {
        console.log(xhr.responseText);
      } 
    };

```
### jqueryAjax
```
var loginBtn =  document.getElementsByTagName("button")[0];
loginBtn.onclick = function(){
      $.ajax({
         type: 'POST',
         url: url,
         data: data,
         dataType: dataType,
         success: function () {},
         error: function () {}
      });
}
```

### fetch

fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。

```
fetch('http://www.mozotech.cn/bangbang/index/user/login', {
    method: 'post',
    headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams([
        ["username", "Lan"],["password", "123456"]
    ]).toString()
})
.then(res => {
    console.log(res);
    return res.text();
})
.then(data => {
    console.log(data);
})

try {
  let response = await fetch(url);
  let data = response.json();
  console.log(data);
} catch(e) {
  console.log("Oops, error", e);
}

```

### axios

```
axios({
    method: 'post',
    url: '/abc/login',
    data: {
        userName: 'Lan',
        password: '123'
    }
})
.then(function (response) {
    console.log(response);
})
.catch(function (error) {
    console.log(error);
});
```

同时发起多个请求：

![img](http://upload-images.jianshu.io/upload_images/7108739-068a63c60ceee6e0?imageMogr2/auto-orient/strip|imageView2/2/w/478/format/webp)

image

### 对比

1. #### 几种方式的对比

   **ajax：**
   【**优点**：局部更新；原生支持】
   【**缺点**：可能破坏浏览器后退功能；嵌套回调】
   **jqueryAjax**：
   【在原生的ajax的基础上进行了封装；支持jsonp】
   **fetch**：
   【**优点**：解决回调地狱】
   【**缺点**：API 偏底层，需要封装;默认不带Cookie，需要手动添加; 浏览器支持情况不是很友好，需要第三方的ployfill】
   **axios**：
   **【**几乎完美】
2. #### axios的特点

   支持浏览器和node.js
   支持promise
   能**拦截**请求和响应
   能转换请求和响应数据
   能**取消**请求
   自动转换JSON数据
   浏览器端支持**防止CSRF**(跨站请求伪造)

## mock.js模拟数据

### EasyMock

### 开始和安装

#### Node (CommonJS)

```
# 安装
npm install mockjs
```

```
// 使用 Mock
var Mock = require('mockjs')
var data = Mock.mock({
    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素
    'list|1-10': [{
        // 属性 id 是一个自增数，起始值为 1，每次增 1
        'id|+1': 1
    }]
})
// 输出结果
console.log(JSON.stringify(data, null, 4))
```

#### Bower

```
# 安装
npm install -g bower
bower install --save mockjs
<script type="text/javascript" src="./bower_components/mockjs/dist/mock.js"></script>
```

